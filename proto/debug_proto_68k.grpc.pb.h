// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: debug_proto_68k.proto
#ifndef GRPC_debug_5fproto_5f68k_2eproto__INCLUDED
#define GRPC_debug_5fproto_5f68k_2eproto__INCLUDED

#include "debug_proto_68k.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace idadebug {

class DbgServer final {
 public:
  static constexpr char const* service_full_name() {
    return "idadebug.DbgServer";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::idadebug::AnyRegValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>> Asyncget_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>>(Asyncget_gp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>> PrepareAsyncget_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>>(PrepareAsyncget_gp_regRaw(context, request, cq));
    }
    virtual ::grpc::Status get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::GpRegs* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>> Asyncget_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>>(Asyncget_gp_regsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>> PrepareAsyncget_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>>(PrepareAsyncget_gp_regsRaw(context, request, cq));
    }
    virtual ::grpc::Status set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncset_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncset_gp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncset_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncset_gp_regRaw(context, request, cq));
    }
    virtual ::grpc::Status get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::idadebug::AnyRegValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>> Asyncget_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>>(Asyncget_vdp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>> PrepareAsyncget_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>>(PrepareAsyncget_vdp_regRaw(context, request, cq));
    }
    virtual ::grpc::Status get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::VdpRegs* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>> Asyncget_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>>(Asyncget_vdp_regsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>> PrepareAsyncget_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>>(PrepareAsyncget_vdp_regsRaw(context, request, cq));
    }
    virtual ::grpc::Status set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncset_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncset_vdp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncset_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncset_vdp_regRaw(context, request, cq));
    }
    virtual ::grpc::Status get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::DmaInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>> Asyncget_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>>(Asyncget_dma_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>> PrepareAsyncget_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>>(PrepareAsyncget_dma_infoRaw(context, request, cq));
    }
    virtual ::grpc::Status read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::idadebug::MemData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>> Asyncread_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>>(Asyncread_memoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>> PrepareAsyncread_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>>(PrepareAsyncread_memoryRaw(context, request, cq));
    }
    virtual ::grpc::Status write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncwrite_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncwrite_memoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncwrite_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncwrite_memoryRaw(context, request, cq));
    }
    virtual ::grpc::Status get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::DbgBreakpoints* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>> Asyncget_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>>(Asyncget_breakpointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>> PrepareAsyncget_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>>(PrepareAsyncget_breakpointsRaw(context, request, cq));
    }
    virtual ::grpc::Status add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncadd_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncadd_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncadd_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncadd_breakpointRaw(context, request, cq));
    }
    virtual ::grpc::Status toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asynctoggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asynctoggle_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsynctoggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsynctoggle_breakpointRaw(context, request, cq));
    }
    virtual ::grpc::Status update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncupdate_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncupdate_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncupdate_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncupdate_breakpointRaw(context, request, cq));
    }
    virtual ::grpc::Status del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncdel_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncdel_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncdel_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncdel_breakpointRaw(context, request, cq));
    }
    virtual ::grpc::Status clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncclear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncclear_breakpointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncclear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncclear_breakpointsRaw(context, request, cq));
    }
    virtual ::grpc::Status pause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncpause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncpauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncpause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncpauseRaw(context, request, cq));
    }
    virtual ::grpc::Status resume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncresume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncresumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncresume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncresumeRaw(context, request, cq));
    }
    virtual ::grpc::Status start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncstart_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncstart_emulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstart_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstart_emulationRaw(context, request, cq));
    }
    virtual ::grpc::Status exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncexit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncexit_emulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncexit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncexit_emulationRaw(context, request, cq));
    }
    virtual ::grpc::Status step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncstep_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncstep_intoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstep_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstep_intoRaw(context, request, cq));
    }
    virtual ::grpc::Status step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncstep_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncstep_overRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstep_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstep_overRaw(context, request, cq));
    }
    virtual ::grpc::Status get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::Callstack* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>> Asyncget_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>>(Asyncget_callstackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>> PrepareAsyncget_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>>(PrepareAsyncget_callstackRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void pause(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pause(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void resume(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void resume(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>* Asyncget_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>* PrepareAsyncget_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>* Asyncget_gp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::GpRegs>* PrepareAsyncget_gp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncset_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncset_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>* Asyncget_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::AnyRegValue>* PrepareAsyncget_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>* Asyncget_vdp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::VdpRegs>* PrepareAsyncget_vdp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncset_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncset_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>* Asyncget_dma_infoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DmaInfo>* PrepareAsyncget_dma_infoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>* Asyncread_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::MemData>* PrepareAsyncread_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncwrite_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncwrite_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>* Asyncget_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::DbgBreakpoints>* PrepareAsyncget_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncadd_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncadd_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asynctoggle_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsynctoggle_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncupdate_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncupdate_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncdel_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncdel_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncclear_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncclear_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncpauseRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncpauseRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncresumeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncresumeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncstart_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstart_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncexit_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncexit_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncstep_intoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstep_intoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncstep_overRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstep_overRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>* Asyncget_callstackRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::idadebug::Callstack>* PrepareAsyncget_callstackRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::idadebug::AnyRegValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>> Asyncget_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>>(Asyncget_gp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>> PrepareAsyncget_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>>(PrepareAsyncget_gp_regRaw(context, request, cq));
    }
    ::grpc::Status get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::GpRegs* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>> Asyncget_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>>(Asyncget_gp_regsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>> PrepareAsyncget_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>>(PrepareAsyncget_gp_regsRaw(context, request, cq));
    }
    ::grpc::Status set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncset_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncset_gp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncset_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncset_gp_regRaw(context, request, cq));
    }
    ::grpc::Status get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::idadebug::AnyRegValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>> Asyncget_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>>(Asyncget_vdp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>> PrepareAsyncget_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>>(PrepareAsyncget_vdp_regRaw(context, request, cq));
    }
    ::grpc::Status get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::VdpRegs* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>> Asyncget_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>>(Asyncget_vdp_regsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>> PrepareAsyncget_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>>(PrepareAsyncget_vdp_regsRaw(context, request, cq));
    }
    ::grpc::Status set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncset_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncset_vdp_regRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncset_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncset_vdp_regRaw(context, request, cq));
    }
    ::grpc::Status get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::DmaInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>> Asyncget_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>>(Asyncget_dma_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>> PrepareAsyncget_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>>(PrepareAsyncget_dma_infoRaw(context, request, cq));
    }
    ::grpc::Status read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::idadebug::MemData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>> Asyncread_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>>(Asyncread_memoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>> PrepareAsyncread_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>>(PrepareAsyncread_memoryRaw(context, request, cq));
    }
    ::grpc::Status write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncwrite_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncwrite_memoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncwrite_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncwrite_memoryRaw(context, request, cq));
    }
    ::grpc::Status get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::DbgBreakpoints* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>> Asyncget_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>>(Asyncget_breakpointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>> PrepareAsyncget_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>>(PrepareAsyncget_breakpointsRaw(context, request, cq));
    }
    ::grpc::Status add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncadd_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncadd_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncadd_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncadd_breakpointRaw(context, request, cq));
    }
    ::grpc::Status toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asynctoggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asynctoggle_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsynctoggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsynctoggle_breakpointRaw(context, request, cq));
    }
    ::grpc::Status update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncupdate_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncupdate_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncupdate_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncupdate_breakpointRaw(context, request, cq));
    }
    ::grpc::Status del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncdel_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncdel_breakpointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncdel_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncdel_breakpointRaw(context, request, cq));
    }
    ::grpc::Status clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncclear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncclear_breakpointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncclear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncclear_breakpointsRaw(context, request, cq));
    }
    ::grpc::Status pause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncpause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncpauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncpause(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncpauseRaw(context, request, cq));
    }
    ::grpc::Status resume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncresume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncresumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncresume(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncresumeRaw(context, request, cq));
    }
    ::grpc::Status start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncstart_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncstart_emulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstart_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstart_emulationRaw(context, request, cq));
    }
    ::grpc::Status exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncexit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncexit_emulationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncexit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncexit_emulationRaw(context, request, cq));
    }
    ::grpc::Status step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncstep_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncstep_intoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstep_into(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstep_intoRaw(context, request, cq));
    }
    ::grpc::Status step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncstep_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncstep_overRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstep_over(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstep_overRaw(context, request, cq));
    }
    ::grpc::Status get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::idadebug::Callstack* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>> Asyncget_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>>(Asyncget_callstackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>> PrepareAsyncget_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>>(PrepareAsyncget_callstackRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response, std::function<void(::grpc::Status)>) override;
      void get_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response, std::function<void(::grpc::Status)>) override;
      void get_gp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void set_gp_reg(::grpc::ClientContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response, std::function<void(::grpc::Status)>) override;
      void get_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response, std::function<void(::grpc::Status)>) override;
      void get_vdp_regs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void set_vdp_reg(::grpc::ClientContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response, std::function<void(::grpc::Status)>) override;
      void get_dma_info(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response, std::function<void(::grpc::Status)>) override;
      void read_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response, ::grpc::ClientUnaryReactor* reactor) override;
      void write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void write_memory(::grpc::ClientContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response, std::function<void(::grpc::Status)>) override;
      void get_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response, ::grpc::ClientUnaryReactor* reactor) override;
      void add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void add_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void toggle_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void update_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void del_breakpoint(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void clear_breakpoints(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pause(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void pause(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void resume(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void resume(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void start_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void exit_emulation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void step_into(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void step_over(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response, std::function<void(::grpc::Status)>) override;
      void get_callstack(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>* Asyncget_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>* PrepareAsyncget_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpReg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>* Asyncget_gp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::GpRegs>* PrepareAsyncget_gp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncset_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncset_gp_regRaw(::grpc::ClientContext* context, const ::idadebug::GpRegValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>* Asyncget_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::AnyRegValue>* PrepareAsyncget_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpReg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>* Asyncget_vdp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::VdpRegs>* PrepareAsyncget_vdp_regsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncset_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncset_vdp_regRaw(::grpc::ClientContext* context, const ::idadebug::VdpRegValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>* Asyncget_dma_infoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::DmaInfo>* PrepareAsyncget_dma_infoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>* Asyncread_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::MemData>* PrepareAsyncread_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAS& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncwrite_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncwrite_memoryRaw(::grpc::ClientContext* context, const ::idadebug::MemoryAD& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>* Asyncget_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::DbgBreakpoints>* PrepareAsyncget_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncadd_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncadd_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asynctoggle_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsynctoggle_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncupdate_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncupdate_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncdel_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncdel_breakpointRaw(::grpc::ClientContext* context, const ::idadebug::DbgBreakpoint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncclear_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncclear_breakpointsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncpauseRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncpauseRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncresumeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncresumeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncstart_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstart_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncexit_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncexit_emulationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncstep_intoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstep_intoRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncstep_overRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstep_overRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>* Asyncget_callstackRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::idadebug::Callstack>* PrepareAsyncget_callstackRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_get_gp_reg_;
    const ::grpc::internal::RpcMethod rpcmethod_get_gp_regs_;
    const ::grpc::internal::RpcMethod rpcmethod_set_gp_reg_;
    const ::grpc::internal::RpcMethod rpcmethod_get_vdp_reg_;
    const ::grpc::internal::RpcMethod rpcmethod_get_vdp_regs_;
    const ::grpc::internal::RpcMethod rpcmethod_set_vdp_reg_;
    const ::grpc::internal::RpcMethod rpcmethod_get_dma_info_;
    const ::grpc::internal::RpcMethod rpcmethod_read_memory_;
    const ::grpc::internal::RpcMethod rpcmethod_write_memory_;
    const ::grpc::internal::RpcMethod rpcmethod_get_breakpoints_;
    const ::grpc::internal::RpcMethod rpcmethod_add_breakpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_toggle_breakpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_update_breakpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_del_breakpoint_;
    const ::grpc::internal::RpcMethod rpcmethod_clear_breakpoints_;
    const ::grpc::internal::RpcMethod rpcmethod_pause_;
    const ::grpc::internal::RpcMethod rpcmethod_resume_;
    const ::grpc::internal::RpcMethod rpcmethod_start_emulation_;
    const ::grpc::internal::RpcMethod rpcmethod_exit_emulation_;
    const ::grpc::internal::RpcMethod rpcmethod_step_into_;
    const ::grpc::internal::RpcMethod rpcmethod_step_over_;
    const ::grpc::internal::RpcMethod rpcmethod_get_callstack_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status get_gp_reg(::grpc::ServerContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response);
    virtual ::grpc::Status get_gp_regs(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response);
    virtual ::grpc::Status set_gp_reg(::grpc::ServerContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status get_vdp_reg(::grpc::ServerContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response);
    virtual ::grpc::Status get_vdp_regs(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response);
    virtual ::grpc::Status set_vdp_reg(::grpc::ServerContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status get_dma_info(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response);
    virtual ::grpc::Status read_memory(::grpc::ServerContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response);
    virtual ::grpc::Status write_memory(::grpc::ServerContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status get_breakpoints(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response);
    virtual ::grpc::Status add_breakpoint(::grpc::ServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status toggle_breakpoint(::grpc::ServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status update_breakpoint(::grpc::ServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status del_breakpoint(::grpc::ServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status clear_breakpoints(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status pause(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status resume(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status start_emulation(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status exit_emulation(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status step_into(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status step_over(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status get_callstack(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gp_reg(::grpc::ServerContext* context, ::idadebug::GpReg* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::AnyRegValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gp_regs(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::GpRegs>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_gp_reg(::grpc::ServerContext* context, ::idadebug::GpRegValue* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vdp_reg(::grpc::ServerContext* context, ::idadebug::VdpReg* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::AnyRegValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vdp_regs(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::VdpRegs>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_vdp_reg(::grpc::ServerContext* context, ::idadebug::VdpRegValue* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_dma_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_dma_info(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::DmaInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_read_memory() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestread_memory(::grpc::ServerContext* context, ::idadebug::MemoryAS* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::MemData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_write_memory() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwrite_memory(::grpc::ServerContext* context, ::idadebug::MemoryAD* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_breakpoints(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::DbgBreakpoints>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_breakpoint(::grpc::ServerContext* context, ::idadebug::DbgBreakpoint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttoggle_breakpoint(::grpc::ServerContext* context, ::idadebug::DbgBreakpoint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestupdate_breakpoint(::grpc::ServerContext* context, ::idadebug::DbgBreakpoint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdel_breakpoint(::grpc::ServerContext* context, ::idadebug::DbgBreakpoint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_breakpoints(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pause() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_resume() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresume(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_start_emulation() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_emulation(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_exit_emulation() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestexit_emulation(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_step_into() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststep_into(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_step_over() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststep_over(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_callstack() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_callstack(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::idadebug::Callstack>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_get_gp_reg<WithAsyncMethod_get_gp_regs<WithAsyncMethod_set_gp_reg<WithAsyncMethod_get_vdp_reg<WithAsyncMethod_get_vdp_regs<WithAsyncMethod_set_vdp_reg<WithAsyncMethod_get_dma_info<WithAsyncMethod_read_memory<WithAsyncMethod_write_memory<WithAsyncMethod_get_breakpoints<WithAsyncMethod_add_breakpoint<WithAsyncMethod_toggle_breakpoint<WithAsyncMethod_update_breakpoint<WithAsyncMethod_del_breakpoint<WithAsyncMethod_clear_breakpoints<WithAsyncMethod_pause<WithAsyncMethod_resume<WithAsyncMethod_start_emulation<WithAsyncMethod_exit_emulation<WithAsyncMethod_step_into<WithAsyncMethod_step_over<WithAsyncMethod_get_callstack<Service > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::GpReg, ::idadebug::AnyRegValue>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::GpReg* request, ::idadebug::AnyRegValue* response) { return this->get_gp_reg(context, request, response); }));}
    void SetMessageAllocatorFor_get_gp_reg(
        ::grpc::MessageAllocator< ::idadebug::GpReg, ::idadebug::AnyRegValue>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::GpReg, ::idadebug::AnyRegValue>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_gp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::GpRegs>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::GpRegs* response) { return this->get_gp_regs(context, request, response); }));}
    void SetMessageAllocatorFor_get_gp_regs(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::idadebug::GpRegs>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::GpRegs>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_gp_regs(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::GpRegValue, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::GpRegValue* request, ::google::protobuf::Empty* response) { return this->set_gp_reg(context, request, response); }));}
    void SetMessageAllocatorFor_set_gp_reg(
        ::grpc::MessageAllocator< ::idadebug::GpRegValue, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::GpRegValue, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_gp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::VdpReg, ::idadebug::AnyRegValue>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::VdpReg* request, ::idadebug::AnyRegValue* response) { return this->get_vdp_reg(context, request, response); }));}
    void SetMessageAllocatorFor_get_vdp_reg(
        ::grpc::MessageAllocator< ::idadebug::VdpReg, ::idadebug::AnyRegValue>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::VdpReg, ::idadebug::AnyRegValue>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_vdp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::VdpRegs>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::VdpRegs* response) { return this->get_vdp_regs(context, request, response); }));}
    void SetMessageAllocatorFor_get_vdp_regs(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::idadebug::VdpRegs>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::VdpRegs>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_vdp_regs(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::VdpRegValue, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::VdpRegValue* request, ::google::protobuf::Empty* response) { return this->set_vdp_reg(context, request, response); }));}
    void SetMessageAllocatorFor_set_vdp_reg(
        ::grpc::MessageAllocator< ::idadebug::VdpRegValue, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::VdpRegValue, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_vdp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_dma_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::DmaInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::DmaInfo* response) { return this->get_dma_info(context, request, response); }));}
    void SetMessageAllocatorFor_get_dma_info(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::idadebug::DmaInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::DmaInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_dma_info(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_read_memory() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::MemoryAS, ::idadebug::MemData>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::MemoryAS* request, ::idadebug::MemData* response) { return this->read_memory(context, request, response); }));}
    void SetMessageAllocatorFor_read_memory(
        ::grpc::MessageAllocator< ::idadebug::MemoryAS, ::idadebug::MemData>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::MemoryAS, ::idadebug::MemData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* read_memory(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_write_memory() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::MemoryAD, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::MemoryAD* request, ::google::protobuf::Empty* response) { return this->write_memory(context, request, response); }));}
    void SetMessageAllocatorFor_write_memory(
        ::grpc::MessageAllocator< ::idadebug::MemoryAD, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::MemoryAD, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* write_memory(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::DbgBreakpoints>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::DbgBreakpoints* response) { return this->get_breakpoints(context, request, response); }));}
    void SetMessageAllocatorFor_get_breakpoints(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::idadebug::DbgBreakpoints>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::DbgBreakpoints>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_breakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response) { return this->add_breakpoint(context, request, response); }));}
    void SetMessageAllocatorFor_add_breakpoint(
        ::grpc::MessageAllocator< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response) { return this->toggle_breakpoint(context, request, response); }));}
    void SetMessageAllocatorFor_toggle_breakpoint(
        ::grpc::MessageAllocator< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* toggle_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response) { return this->update_breakpoint(context, request, response); }));}
    void SetMessageAllocatorFor_update_breakpoint(
        ::grpc::MessageAllocator< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* update_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::DbgBreakpoint* request, ::google::protobuf::Empty* response) { return this->del_breakpoint(context, request, response); }));}
    void SetMessageAllocatorFor_del_breakpoint(
        ::grpc::MessageAllocator< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* del_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->clear_breakpoints(context, request, response); }));}
    void SetMessageAllocatorFor_clear_breakpoints(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_breakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pause() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->pause(context, request, response); }));}
    void SetMessageAllocatorFor_pause(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_resume() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->resume(context, request, response); }));}
    void SetMessageAllocatorFor_resume(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resume(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_start_emulation() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->start_emulation(context, request, response); }));}
    void SetMessageAllocatorFor_start_emulation(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_emulation(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_exit_emulation() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->exit_emulation(context, request, response); }));}
    void SetMessageAllocatorFor_exit_emulation(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* exit_emulation(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_step_into() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->step_into(context, request, response); }));}
    void SetMessageAllocatorFor_step_into(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* step_into(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_step_over() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->step_over(context, request, response); }));}
    void SetMessageAllocatorFor_step_over(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* step_over(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_callstack() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::Callstack>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::idadebug::Callstack* response) { return this->get_callstack(context, request, response); }));}
    void SetMessageAllocatorFor_get_callstack(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::idadebug::Callstack>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::idadebug::Callstack>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_callstack(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_get_gp_reg<WithCallbackMethod_get_gp_regs<WithCallbackMethod_set_gp_reg<WithCallbackMethod_get_vdp_reg<WithCallbackMethod_get_vdp_regs<WithCallbackMethod_set_vdp_reg<WithCallbackMethod_get_dma_info<WithCallbackMethod_read_memory<WithCallbackMethod_write_memory<WithCallbackMethod_get_breakpoints<WithCallbackMethod_add_breakpoint<WithCallbackMethod_toggle_breakpoint<WithCallbackMethod_update_breakpoint<WithCallbackMethod_del_breakpoint<WithCallbackMethod_clear_breakpoints<WithCallbackMethod_pause<WithCallbackMethod_resume<WithCallbackMethod_start_emulation<WithCallbackMethod_exit_emulation<WithCallbackMethod_step_into<WithCallbackMethod_step_over<WithCallbackMethod_get_callstack<Service > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_dma_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_read_memory() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_write_memory() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pause() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_resume() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_start_emulation() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_exit_emulation() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_step_into() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_step_over() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_callstack() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gp_reg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_gp_regs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_gp_reg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vdp_reg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_vdp_regs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_vdp_reg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_dma_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_dma_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_read_memory() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestread_memory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_write_memory() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwrite_memory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_breakpoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_breakpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttoggle_breakpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestupdate_breakpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdel_breakpoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear_breakpoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pause() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_resume() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestresume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_start_emulation() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_emulation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_exit_emulation() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestexit_emulation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_step_into() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststep_into(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_step_over() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststep_over(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_callstack() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_callstack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_gp_reg(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_gp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_gp_regs(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_gp_regs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_gp_reg(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_gp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_vdp_reg(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_vdp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_vdp_regs(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_vdp_regs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_vdp_reg(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_vdp_reg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_dma_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_dma_info(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_dma_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_read_memory() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->read_memory(context, request, response); }));
    }
    ~WithRawCallbackMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* read_memory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_write_memory() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->write_memory(context, request, response); }));
    }
    ~WithRawCallbackMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* write_memory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_breakpoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_breakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->add_breakpoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* add_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->toggle_breakpoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* toggle_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->update_breakpoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* update_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->del_breakpoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* del_breakpoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clear_breakpoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear_breakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pause() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pause(context, request, response); }));
    }
    ~WithRawCallbackMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_resume() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->resume(context, request, response); }));
    }
    ~WithRawCallbackMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* resume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_start_emulation() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->start_emulation(context, request, response); }));
    }
    ~WithRawCallbackMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_emulation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_exit_emulation() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->exit_emulation(context, request, response); }));
    }
    ~WithRawCallbackMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* exit_emulation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_step_into() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->step_into(context, request, response); }));
    }
    ~WithRawCallbackMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* step_into(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_step_over() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->step_over(context, request, response); }));
    }
    ~WithRawCallbackMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* step_over(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_callstack() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_callstack(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_callstack(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_gp_reg() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::GpReg, ::idadebug::AnyRegValue>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::GpReg, ::idadebug::AnyRegValue>* streamer) {
                       return this->Streamedget_gp_reg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_gp_reg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::GpReg,::idadebug::AnyRegValue>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_gp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_gp_regs() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::idadebug::GpRegs>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::idadebug::GpRegs>* streamer) {
                       return this->Streamedget_gp_regs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_gp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_gp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::GpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_gp_regs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::idadebug::GpRegs>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_gp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_gp_reg() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::GpRegValue, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::GpRegValue, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedset_gp_reg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_gp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_gp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::GpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_gp_reg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::GpRegValue,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_vdp_reg() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::VdpReg, ::idadebug::AnyRegValue>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::VdpReg, ::idadebug::AnyRegValue>* streamer) {
                       return this->Streamedget_vdp_reg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpReg* /*request*/, ::idadebug::AnyRegValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_vdp_reg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::VdpReg,::idadebug::AnyRegValue>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_vdp_regs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_vdp_regs() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::idadebug::VdpRegs>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::idadebug::VdpRegs>* streamer) {
                       return this->Streamedget_vdp_regs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_vdp_regs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_vdp_regs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::VdpRegs* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_vdp_regs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::idadebug::VdpRegs>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_vdp_reg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_vdp_reg() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::VdpRegValue, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::VdpRegValue, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedset_vdp_reg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_vdp_reg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_vdp_reg(::grpc::ServerContext* /*context*/, const ::idadebug::VdpRegValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_vdp_reg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::VdpRegValue,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_dma_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_dma_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::idadebug::DmaInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::idadebug::DmaInfo>* streamer) {
                       return this->Streamedget_dma_info(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_dma_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_dma_info(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DmaInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_dma_info(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::idadebug::DmaInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_read_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_read_memory() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::MemoryAS, ::idadebug::MemData>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::MemoryAS, ::idadebug::MemData>* streamer) {
                       return this->Streamedread_memory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_read_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status read_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAS* /*request*/, ::idadebug::MemData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedread_memory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::MemoryAS,::idadebug::MemData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_write_memory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_write_memory() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::MemoryAD, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::MemoryAD, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedwrite_memory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_write_memory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status write_memory(::grpc::ServerContext* /*context*/, const ::idadebug::MemoryAD* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedwrite_memory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::MemoryAD,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_breakpoints() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::idadebug::DbgBreakpoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::idadebug::DbgBreakpoints>* streamer) {
                       return this->Streamedget_breakpoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::DbgBreakpoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_breakpoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::idadebug::DbgBreakpoints>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_add_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_add_breakpoint() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedadd_breakpoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_add_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status add_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedadd_breakpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::DbgBreakpoint,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_toggle_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_toggle_breakpoint() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedtoggle_breakpoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_toggle_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status toggle_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtoggle_breakpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::DbgBreakpoint,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_update_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_update_breakpoint() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedupdate_breakpoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_update_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status update_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedupdate_breakpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::DbgBreakpoint,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_del_breakpoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_del_breakpoint() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::DbgBreakpoint, ::google::protobuf::Empty>* streamer) {
                       return this->Streameddel_breakpoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_del_breakpoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status del_breakpoint(::grpc::ServerContext* /*context*/, const ::idadebug::DbgBreakpoint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddel_breakpoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::DbgBreakpoint,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clear_breakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clear_breakpoints() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedclear_breakpoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clear_breakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clear_breakpoints(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclear_breakpoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pause() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedpause(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pause(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_resume() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedresume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status resume(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedresume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_start_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_start_emulation() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedstart_emulation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_start_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status start_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstart_emulation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_exit_emulation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_exit_emulation() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedexit_emulation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_exit_emulation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status exit_emulation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedexit_emulation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_step_into : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_step_into() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedstep_into(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_step_into() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status step_into(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstep_into(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_step_over : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_step_over() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedstep_over(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_step_over() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status step_over(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstep_over(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_callstack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_callstack() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::idadebug::Callstack>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::idadebug::Callstack>* streamer) {
                       return this->Streamedget_callstack(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_callstack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_callstack(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::idadebug::Callstack* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_callstack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::idadebug::Callstack>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_gp_reg<WithStreamedUnaryMethod_get_gp_regs<WithStreamedUnaryMethod_set_gp_reg<WithStreamedUnaryMethod_get_vdp_reg<WithStreamedUnaryMethod_get_vdp_regs<WithStreamedUnaryMethod_set_vdp_reg<WithStreamedUnaryMethod_get_dma_info<WithStreamedUnaryMethod_read_memory<WithStreamedUnaryMethod_write_memory<WithStreamedUnaryMethod_get_breakpoints<WithStreamedUnaryMethod_add_breakpoint<WithStreamedUnaryMethod_toggle_breakpoint<WithStreamedUnaryMethod_update_breakpoint<WithStreamedUnaryMethod_del_breakpoint<WithStreamedUnaryMethod_clear_breakpoints<WithStreamedUnaryMethod_pause<WithStreamedUnaryMethod_resume<WithStreamedUnaryMethod_start_emulation<WithStreamedUnaryMethod_exit_emulation<WithStreamedUnaryMethod_step_into<WithStreamedUnaryMethod_step_over<WithStreamedUnaryMethod_get_callstack<Service > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_get_gp_reg<WithStreamedUnaryMethod_get_gp_regs<WithStreamedUnaryMethod_set_gp_reg<WithStreamedUnaryMethod_get_vdp_reg<WithStreamedUnaryMethod_get_vdp_regs<WithStreamedUnaryMethod_set_vdp_reg<WithStreamedUnaryMethod_get_dma_info<WithStreamedUnaryMethod_read_memory<WithStreamedUnaryMethod_write_memory<WithStreamedUnaryMethod_get_breakpoints<WithStreamedUnaryMethod_add_breakpoint<WithStreamedUnaryMethod_toggle_breakpoint<WithStreamedUnaryMethod_update_breakpoint<WithStreamedUnaryMethod_del_breakpoint<WithStreamedUnaryMethod_clear_breakpoints<WithStreamedUnaryMethod_pause<WithStreamedUnaryMethod_resume<WithStreamedUnaryMethod_start_emulation<WithStreamedUnaryMethod_exit_emulation<WithStreamedUnaryMethod_step_into<WithStreamedUnaryMethod_step_over<WithStreamedUnaryMethod_get_callstack<Service > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

class DbgClient final {
 public:
  static constexpr char const* service_full_name() {
    return "idadebug.DbgClient";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncstart_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncstart_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstart_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstart_eventRaw(context, request, cq));
    }
    virtual ::grpc::Status pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncpause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncpause_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncpause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncpause_eventRaw(context, request, cq));
    }
    virtual ::grpc::Status stop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> Asyncstop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(Asyncstop_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncstop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncstop_eventRaw(context, request, cq));
    }
    virtual ::grpc::Status eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::google::protobuf::BoolValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>> Asynceval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>>(Asynceval_conditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>> PrepareAsynceval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>>(PrepareAsynceval_conditionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void stop_event(::grpc::ClientContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void stop_event(::grpc::ClientContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response, std::function<void(::grpc::Status)>) = 0;
      virtual void eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncstart_eventRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstart_eventRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncpause_eventRaw(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncpause_eventRaw(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* Asyncstop_eventRaw(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncstop_eventRaw(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>* Asynceval_conditionRaw(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::BoolValue>* PrepareAsynceval_conditionRaw(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncstart_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncstart_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstart_event(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstart_eventRaw(context, request, cq));
    }
    ::grpc::Status pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncpause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncpause_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncpause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncpause_eventRaw(context, request, cq));
    }
    ::grpc::Status stop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> Asyncstop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(Asyncstop_eventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncstop_event(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncstop_eventRaw(context, request, cq));
    }
    ::grpc::Status eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::google::protobuf::BoolValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>> Asynceval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>>(Asynceval_conditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>> PrepareAsynceval_condition(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>>(PrepareAsynceval_conditionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void start_event(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void pause_event(::grpc::ClientContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void stop_event(::grpc::ClientContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void stop_event(::grpc::ClientContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response, std::function<void(::grpc::Status)>) override;
      void eval_condition(::grpc::ClientContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncstart_eventRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstart_eventRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncpause_eventRaw(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncpause_eventRaw(::grpc::ClientContext* context, const ::idadebug::PauseChanged& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* Asyncstop_eventRaw(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncstop_eventRaw(::grpc::ClientContext* context, const ::idadebug::Changed& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>* Asynceval_conditionRaw(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::BoolValue>* PrepareAsynceval_conditionRaw(::grpc::ClientContext* context, const ::idadebug::Condition& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_start_event_;
    const ::grpc::internal::RpcMethod rpcmethod_pause_event_;
    const ::grpc::internal::RpcMethod rpcmethod_stop_event_;
    const ::grpc::internal::RpcMethod rpcmethod_eval_condition_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status start_event(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status pause_event(::grpc::ServerContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status stop_event(::grpc::ServerContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status eval_condition(::grpc::ServerContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_start_event() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_event(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_pause_event() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause_event(::grpc::ServerContext* context, ::idadebug::PauseChanged* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_stop_event() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop_event(::grpc::ServerContext* context, ::idadebug::Changed* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_eval_condition() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesteval_condition(::grpc::ServerContext* context, ::idadebug::Condition* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::BoolValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_start_event<WithAsyncMethod_pause_event<WithAsyncMethod_stop_event<WithAsyncMethod_eval_condition<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_start_event() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->start_event(context, request, response); }));}
    void SetMessageAllocatorFor_start_event(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_event(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_pause_event() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::PauseChanged, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::PauseChanged* request, ::google::protobuf::Empty* response) { return this->pause_event(context, request, response); }));}
    void SetMessageAllocatorFor_pause_event(
        ::grpc::MessageAllocator< ::idadebug::PauseChanged, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::PauseChanged, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause_event(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_stop_event() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::Changed, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::Changed* request, ::google::protobuf::Empty* response) { return this->stop_event(context, request, response); }));}
    void SetMessageAllocatorFor_stop_event(
        ::grpc::MessageAllocator< ::idadebug::Changed, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::Changed, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop_event(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_eval_condition() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::idadebug::Condition, ::google::protobuf::BoolValue>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::idadebug::Condition* request, ::google::protobuf::BoolValue* response) { return this->eval_condition(context, request, response); }));}
    void SetMessageAllocatorFor_eval_condition(
        ::grpc::MessageAllocator< ::idadebug::Condition, ::google::protobuf::BoolValue>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::idadebug::Condition, ::google::protobuf::BoolValue>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* eval_condition(
      ::grpc::CallbackServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_start_event<WithCallbackMethod_pause_event<WithCallbackMethod_stop_event<WithCallbackMethod_eval_condition<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_start_event() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_pause_event() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_stop_event() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_eval_condition() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_start_event() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststart_event(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_pause_event() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpause_event(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_stop_event() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststop_event(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_eval_condition() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesteval_condition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_start_event() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->start_event(context, request, response); }));
    }
    ~WithRawCallbackMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* start_event(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_pause_event() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->pause_event(context, request, response); }));
    }
    ~WithRawCallbackMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* pause_event(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_stop_event() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->stop_event(context, request, response); }));
    }
    ~WithRawCallbackMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* stop_event(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_eval_condition() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->eval_condition(context, request, response); }));
    }
    ~WithRawCallbackMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* eval_condition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_start_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_start_event() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedstart_event(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_start_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status start_event(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstart_event(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_pause_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_pause_event() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::PauseChanged, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::PauseChanged, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedpause_event(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_pause_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status pause_event(::grpc::ServerContext* /*context*/, const ::idadebug::PauseChanged* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpause_event(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::PauseChanged,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_stop_event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_stop_event() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::Changed, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::Changed, ::google::protobuf::Empty>* streamer) {
                       return this->Streamedstop_event(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_stop_event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status stop_event(::grpc::ServerContext* /*context*/, const ::idadebug::Changed* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstop_event(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::Changed,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_eval_condition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_eval_condition() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::idadebug::Condition, ::google::protobuf::BoolValue>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::idadebug::Condition, ::google::protobuf::BoolValue>* streamer) {
                       return this->Streamedeval_condition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_eval_condition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status eval_condition(::grpc::ServerContext* /*context*/, const ::idadebug::Condition* /*request*/, ::google::protobuf::BoolValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedeval_condition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::idadebug::Condition,::google::protobuf::BoolValue>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_start_event<WithStreamedUnaryMethod_pause_event<WithStreamedUnaryMethod_stop_event<WithStreamedUnaryMethod_eval_condition<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_start_event<WithStreamedUnaryMethod_pause_event<WithStreamedUnaryMethod_stop_event<WithStreamedUnaryMethod_eval_condition<Service > > > > StreamedService;
};

}  // namespace idadebug


#endif  // GRPC_debug_5fproto_5f68k_2eproto__INCLUDED
